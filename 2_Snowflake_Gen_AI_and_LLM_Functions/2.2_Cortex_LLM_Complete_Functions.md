[< Domain 2 Overview](./README.md) | **2.2 Cortex LLM Complete Functions** | [Cortex Chat Functions >](./2.3_Cortex_Chat_Functions.md)
***

# 2.2 Cortex LLM Complete Functions

## Overview

Snowflake Cortex LLM Complete functions provide text generation capabilities through industry-leading large language models. These functions enable single-turn text generation for various use cases including content creation, code generation, analysis, and transformation.

## Core Complete Functions

### COMPLETE()
Primary text generation function for single-turn completions.

```sql
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    model_name,
    prompt,
    options_object  -- Optional
) as completion;
```

### TRY_COMPLETE()
Error-safe variant that returns NULL instead of throwing errors.

```sql
SELECT SNOWFLAKE.CORTEX.TRY_COMPLETE(
    'llama3.1-70b',
    potentially_problematic_prompt
) as safe_completion;
```

## Available Models for Complete Functions

### **Large Models** (Complex reasoning, highest capability)
```sql
-- Claude models - Superior reasoning and analysis
SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet', prompt)  -- Best overall performance
SNOWFLAKE.CORTEX.COMPLETE('claude-4-sonnet', prompt)    -- Multimodal capabilities

-- Mistral models - Multilingual excellence
SNOWFLAKE.CORTEX.COMPLETE('mistral-large2', prompt)     -- Top-tier performance

-- LLaMA models - Open source power
SNOWFLAKE.CORTEX.COMPLETE('llama3.1-405b', prompt)     -- Largest open model
SNOWFLAKE.CORTEX.COMPLETE('llama3.1-70b', prompt)      -- Balanced performance

-- Specialized models
SNOWFLAKE.CORTEX.COMPLETE('reka-core', prompt)         -- Code generation focus
```

### **Medium Models** (Balanced performance/cost)
```sql
-- Efficient models for most tasks
SNOWFLAKE.CORTEX.COMPLETE('snowflake-arctic', prompt)   -- Enterprise-optimized
SNOWFLAKE.CORTEX.COMPLETE('mixtral-8x7b', prompt)      -- Fast inference
SNOWFLAKE.CORTEX.COMPLETE('jamba-instruct', prompt)    -- 256K context window
```

### **Small Models** (Fast and cost-effective)
```sql
-- For simple tasks and high throughput
SNOWFLAKE.CORTEX.COMPLETE('llama3.1-8b', prompt)       -- 128K context
SNOWFLAKE.CORTEX.COMPLETE('mistral-7b', prompt)        -- 32K context  
SNOWFLAKE.CORTEX.COMPLETE('gemma-7b', prompt)          -- Very cost-effective
```

## Function Options

### Temperature Control
Controls randomness in generation (0.0 = deterministic, 1.0 = very random).

```sql
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'llama3.1-70b',
    'Write a creative story about AI.',
    {'temperature': 0.8}  -- More creative
) as creative_response;

SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'claude-3-5-sonnet',
    'What is 2+2?',
    {'temperature': 0.0}  -- Deterministic
) as factual_response;
```

### Max Tokens
Limits the length of generated responses.

```sql
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'mistral-large2',
    'Explain machine learning in detail.',
    {'max_tokens': 200}  -- Limit to ~200 tokens
) as brief_explanation;
```

### Top-P (Nucleus Sampling)
Controls diversity by limiting token selection to top probability mass.

```sql
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'llama3.1-70b',
    'Generate product descriptions.',
    {
        'temperature': 0.7,
        'top_p': 0.9  -- Consider tokens up to 90% cumulative probability
    }
) as balanced_generation;
```

## Common Use Cases

### Content Generation

#### Product Descriptions
```sql
-- Generate product descriptions from features
SELECT 
    product_id,
    product_name,
    SNOWFLAKE.CORTEX.COMPLETE(
        'claude-3-5-sonnet',
        CONCAT(
            'Write a compelling product description for: ',
            product_name, '. Features: ', features,
            '. Target audience: ', target_audience,
            '. Tone: professional and engaging.'
        ),
        {'temperature': 0.7, 'max_tokens': 150}
    ) as generated_description
FROM products
WHERE description IS NULL;
```

#### Email Templates
```sql
-- Generate personalized email templates
SELECT 
    customer_id,
    SNOWFLAKE.CORTEX.COMPLETE(
        'mistral-large2',
        CONCAT(
            'Write a professional follow-up email for customer: ',
            customer_name, ' who purchased: ', product_name,
            ' on ', purchase_date::STRING,
            '. Include thank you and support information.'
        )
    ) as follow_up_email
FROM recent_purchases;
```

### Data Analysis & Insights

#### Text Analysis
```sql
-- Analyze customer feedback
SELECT 
    feedback_id,
    customer_feedback,
    SNOWFLAKE.CORTEX.COMPLETE(
        'claude-3-5-sonnet',
        CONCAT(
            'Analyze this customer feedback and provide insights: "',
            customer_feedback, '"',
            ' Identify: 1) Main concerns 2) Sentiment 3) Actionable items'
        )
    ) as feedback_analysis
FROM customer_feedback
WHERE analysis IS NULL;
```

#### Report Generation
```sql
-- Generate executive summaries
WITH sales_metrics AS (
    SELECT 
        SUM(revenue) as total_revenue,
        COUNT(*) as total_orders,
        AVG(order_value) as avg_order_value
    FROM sales_data
    WHERE date >= '2024-01-01'
)
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'llama3.1-70b',
    CONCAT(
        'Create an executive summary for Q1 2024 sales performance: ',
        'Total Revenue: $', total_revenue::STRING,
        ', Total Orders: ', total_orders::STRING,
        ', Average Order Value: $', avg_order_value::STRING,
        '. Include key insights and recommendations.'
    ),
    {'temperature': 0.3}  -- More factual
) as executive_summary
FROM sales_metrics;
```

### Code Generation

#### SQL Query Generation
```sql
-- Generate SQL queries from natural language
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'reka-core',  -- Specialized for code
    CONCAT(
        'Generate a SQL query for the following request: ',
        user_request,
        ' Schema information: ', table_schema
    )
) as generated_sql
FROM query_requests;
```

#### Data Transformation Logic
```sql
-- Generate transformation rules
SELECT SNOWFLAKE.CORTEX.COMPLETE(
    'claude-3-5-sonnet',
    CONCAT(
        'Create data transformation logic to convert ',
        source_format, ' to ', target_format,
        '. Sample data: ', sample_data
    )
) as transformation_logic
FROM transformation_tasks;
```

### Documentation & Explanations

#### Technical Documentation
```sql
-- Generate API documentation
SELECT 
    function_name,
    SNOWFLAKE.CORTEX.COMPLETE(
        'claude-3-5-sonnet',
        CONCAT(
            'Write technical documentation for this function: ',
            function_name, ' Parameters: ', parameters,
            ' Purpose: ', function_purpose,
            ' Include usage examples and best practices.'
        )
    ) as documentation
FROM api_functions;
```

## Batch Processing Patterns

### Processing Large Datasets
```sql
-- Process in batches to manage costs and performance
CREATE OR REPLACE PROCEDURE process_completions_batch(batch_size INTEGER)
RETURNS STRING
LANGUAGE SQL
AS $$
DECLARE
    processed_count INTEGER := 0;
    total_batches INTEGER;
BEGIN
    SELECT CEIL(COUNT(*) / batch_size) INTO total_batches
    FROM pending_completions;
    
    FOR batch_num IN 1 TO total_batches DO
        INSERT INTO completed_tasks
        SELECT 
            id,
            input_text,
            SNOWFLAKE.CORTEX.COMPLETE('llama3.1-70b', input_text) as completion,
            CURRENT_TIMESTAMP() as processed_at
        FROM (
            SELECT * FROM pending_completions
            WHERE processed = FALSE
            LIMIT batch_size
        );
        
        UPDATE pending_completions 
        SET processed = TRUE
        WHERE id IN (
            SELECT id FROM pending_completions
            WHERE processed = FALSE
            LIMIT batch_size
        );
        
        SET processed_count = processed_count + batch_size;
    END FOR;
    
    RETURN 'Processed ' || processed_count || ' completions';
END;
$$;
```

### Parallel Processing with Different Models
```sql
-- Route different types of tasks to appropriate models
INSERT INTO completions_results
SELECT 
    task_id,
    task_type,
    input_text,
    CASE task_type
        WHEN 'creative_writing' THEN 
            SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet', input_text, {'temperature': 0.8})
        WHEN 'data_analysis' THEN 
            SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet', input_text, {'temperature': 0.2})
        WHEN 'code_generation' THEN 
            SNOWFLAKE.CORTEX.COMPLETE('reka-core', input_text)
        WHEN 'simple_qa' THEN 
            SNOWFLAKE.CORTEX.COMPLETE('llama3.1-8b', input_text)
        ELSE 
            SNOWFLAKE.CORTEX.COMPLETE('llama3.1-70b', input_text)
    END as completion
FROM completion_tasks
WHERE status = 'pending';
```

## Error Handling & Monitoring

### Robust Error Handling
```sql
-- Handle various error conditions
SELECT 
    request_id,
    input_text,
    CASE 
        WHEN SNOWFLAKE.CORTEX.COUNT_TOKENS('llama3.1-70b', input_text) > 4000 THEN
            'Input too long for processing'
        WHEN LENGTH(input_text) < 10 THEN
            'Input too short for meaningful completion'
        ELSE
            COALESCE(
                SNOWFLAKE.CORTEX.TRY_COMPLETE('llama3.1-70b', input_text),
                'Completion failed - please retry'
            )
    END as safe_completion
FROM user_requests;
```

### Usage Monitoring
```sql
-- Monitor completion usage and costs
SELECT 
    DATE_TRUNC('hour', timestamp) as hour,
    model_name,
    COUNT(*) as request_count,
    SUM(input_tokens) as total_input_tokens,
    SUM(output_tokens) as total_output_tokens,
    AVG(latency_ms) as avg_latency
FROM TABLE(INFORMATION_SCHEMA.CORTEX_FUNCTIONS_USAGE_HISTORY(
    DATE_ADD('day', -7, CURRENT_DATE()),
    CURRENT_DATE()
))
WHERE function_name = 'COMPLETE'
GROUP BY 1, 2
ORDER BY 1 DESC, 3 DESC;
```

## Performance Optimization

### Model Selection Strategy
```sql
-- Choose optimal model based on task complexity
CREATE OR REPLACE FUNCTION select_optimal_model(task_type STRING, complexity_score INTEGER)
RETURNS STRING
AS $$
    CASE 
        WHEN task_type = 'simple_qa' AND complexity_score < 3 THEN 'llama3.1-8b'
        WHEN task_type = 'analysis' AND complexity_score >= 7 THEN 'claude-3-5-sonnet'
        WHEN task_type = 'code' THEN 'reka-core'
        WHEN complexity_score >= 8 THEN 'mistral-large2'
        WHEN complexity_score >= 5 THEN 'llama3.1-70b'
        ELSE 'llama3.1-8b'
    END
$$;
```

### Caching Results
```sql
-- Cache completions to avoid reprocessing
CREATE TABLE completion_cache (
    prompt_hash STRING,
    model_name STRING,
    completion_result STRING,
    created_at TIMESTAMP,
    PRIMARY KEY (prompt_hash, model_name)
);

-- Use cached results when available
WITH cached_result AS (
    SELECT completion_result
    FROM completion_cache
    WHERE prompt_hash = SHA2(?, 256) AND model_name = ?
    AND created_at > DATEADD('day', -7, CURRENT_TIMESTAMP())
)
SELECT 
    COALESCE(
        (SELECT completion_result FROM cached_result),
        SNOWFLAKE.CORTEX.COMPLETE(?, ?)
    ) as final_result;
```

## Study Questions

1. **Which function should you use for error-safe LLM completions?**
   - A) COMPLETE()
   - B) TRY_COMPLETE()
   - C) SAFE_COMPLETE()
   - D) ERROR_COMPLETE()

2. **What parameter controls the randomness of generated text?**
   - A) max_tokens
   - B) top_p
   - C) temperature
   - D) creativity

3. **Which model is most cost-effective for simple question-answering tasks?**
   - A) claude-3-5-sonnet
   - B) mistral-large2
   - C) llama3.1-70b
   - D) llama3.1-8b

**Answers: 1-B, 2-C, 3-D**

***
[< Domain 2 Overview](./README.md) | **2.2 Cortex LLM Complete Functions** | [Cortex Chat Functions >](./2.3_Cortex_Chat_Functions.md) 